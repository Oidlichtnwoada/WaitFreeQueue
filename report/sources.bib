@article{WFQ,
issn = {03621340},
abstract = {<p><p>Concurrent data structures that have fast and predictable performance are of critical importance for harnessing the power of multicore processors, which are now ubiquitous. Although wait-free objects, whose operations complete in a bounded number of steps, were devised more than two decades ago, wait-free objects that can deliver scalable high performance are still rare.</p> <p>In this paper, we present the first wait-free FIFO queue based on fetch-and-add (FAA). While compare-and-swap (CAS) based non-blocking algorithms may perform poorly due to work wasted by CAS failures, algorithms that coordinate using FAA, which is guaranteed to succeed, can in principle perform better under high contention. Along with FAA, our queue uses a custom epoch-based scheme to reclaim memory; on x86 architectures, it requires no extra memory fences on our algorithm's typical execution path. An empirical study of our new FAA-based wait-free FIFO queue under high contention on four different architectures with many hardware threads shows that it outperforms prior queue designs that lack a wait-free progress guarantee. Surprisingly, at the highest level of contention, the throughput of our queue is often as high as that of a microbenchmark that only performs FAA. As a result, our fast wait-free queue implementation is useful in practice on most multi-core systems today. We believe that our design can serve as an example of how to construct other fast wait-free objects.</p></p>},
journal = {ACM SIGPLAN Notices},
pages = {1--13},
volume = {51},
publisher = {ACM},
number = {8},
year = {2016},
title = {A wait-free queue as fast as fetch-and-add},
language = {eng},
author = {Yang, Chaoran and Mellor-Crummey, John},
keywords = {Fast-Path-Slow-Path ; Non-Blocking Queue ; Wait-Free ; Computer Science},
}
@inproceedings{FPSP,
series = {PPoPP '12},
abstract = {<p><p>Lock-freedom is a progress guarantee that ensures overall program progress. Wait-freedom is a stronger progress guarantee that ensures the progress of each thread in the program. While many practical lock-free algorithms exist, wait-free algorithms are typically inefficient and hardly used in practice. In this paper, we propose a methodology called <i>fast-path-slow-path</i> for creating efficient wait-free algorithms. The idea is to execute the efficient lock-free version most of the time and revert to the wait-free version only when things go wrong. The generality and effectiveness of this methodology is demonstrated by two examples. In this paper, we apply this idea to a recent construction of a wait-free queue, bringing the wait-free implementation to perform in practice as efficient as the lock-free implementation. In another work, the fast-path-slow-path methodology has been used for (dramatically) improving the performance of a wait-free linked-list.</p></p>},
pages = {141--150},
publisher = {ACM},
booktitle = {Proceedings of the 17th ACM SIGPLAN symposium on principles and practice of parallel programming},
isbn = {9781450311601},
year = {2012},
title = {A methodology for creating fast wait-free data structures},
language = {eng},
author = {Kogan, Alex and Petrank, Erez},
keywords = {Concurrent Data Structures ; Lock-Free Algorithms ; Non-Blocking Synchronization ; Wait-Free Queues ; Computer Science},
}
@online{LFQ,
title={A Fast General Purpose Lock-Free Queue for C++},
url={https://moodycamel.com/blog/2014/a-fast-general-purpose-lock-free-queue-for-c++.htm},
journal={moodycamel.com},
author={Desrochers, Cameron},
date={2014-11-06}
}
@online{LFQEXPL,
title={Detailed Design of a Lock-Free Queue},
url={https://moodycamel.com/blog/2014/detailed-design-of-a-lock-free-queue.htm},
journal={moodycamel.com},
author={Desrochers, Cameron},
date={2014-11-06}
}
@inproceedings{MG11,
author = {Majo, Zoltan and Gross, Thomas R.},
title = {Memory System Performance in a NUMA Multicore Multiprocessor},
year = {2011},
isbn = {9781450307734},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1987816.1987832},
doi = {10.1145/1987816.1987832},
booktitle = {Proceedings of the 4th Annual International Conference on Systems and Storage},
articleno = {12},
numpages = {10},
keywords = {multicore processors, NUMA, memory system performance},
location = {Haifa, Israel},
series = {SYSTOR ’11}
}
@inproceedings{MA13,
author = {Morrison, Adam and Afek, Yehuda},
title = {Fast Concurrent Queues for X86 Processors},
year = {2013},
isbn = {9781450319225},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2442516.2442527},
doi = {10.1145/2442516.2442527},
booktitle = {Proceedings of the 18th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming},
pages = {103–112},
numpages = {10},
keywords = {fetch-and-add, concurrent queue, nonblocking algorithm},
location = {Shenzhen, China},
series = {PPoPP ’13}
}
@article{LIN,
issn = {Concurrency and Computation: Practice and Experience},
journal = {Concurrency and Computation: Practice and Experience},
pages = {e3928},
volume = {29},
number = {4},
year = {2017},
title = {Testing for linearizability: TESTING FOR LINEARIZABILITY},
language = {eng},
author = {Lowe, Gavin},
keywords = {Algorithms;},
}

